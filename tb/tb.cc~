//========================================================================== //
// Copyright (c) 2020, Stephen Henry
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//========================================================================== //

#include "tb.h"
#include "vsupport.h"
#include "test.h"
#ifdef OPT_TRACE_ENABLE
#  include <iostream>
#endif
#ifdef OPT_VCD_ENABLE
#  include "verilated_vcd_c.h"
#endif
#include "gtest/gtest.h"

namespace tb {

std::ostream& operator<<(std::ostream& os, const DataPacket& dp) {
  os << "[";
  for (std::size_t i = 0; i < dp.size(); i++) {
    if (i != 0) {
      os << ", ";
    }
    os << dp[i];
  }
  os << "]";
  return os;
}

// Set unsorted input interface.
void VSignals::set(const VIn& in) {
  vsupport::set(in_vld_, in.vld);
  vsupport::set(in_sop_, in.sop);
  vsupport::set(in_eop_, in.eop);
  vsupport::set(in_dat_, in.dat);
}

void VSignals::set_clk(bool clk) {
  vsupport::set(clk_, clk);
}

void VSignals::set_rst(bool rst) {
  vsupport::set(rst_, rst);
}

// Sample 'in_rdy' port.
bool VSignals::in_rdy() const {
  return vsupport::get_as_bool(in_rdy_);
}

// Sample sorted output interface.
void VSignals::get(VOut& out) const {
  out.vld = vsupport::get(out_vld_r_);
  out.sop = vsupport::get(out_sop_r_);
  out.eop = vsupport::get(out_eop_r_);
  out.dat = vsupport::get(out_dat_r_);
}

// Obtain current simulation cycle.
vluint64_t VSignals::cycle() const {
  return vsupport::get(tb_cycle_);
}

TB::TB(const Options& opts)
    : opts_(opts) {
#ifdef OPT_VCD_ENABLE
  if (opts.wave_enable) {
    Verilated::traceEverOn(true);
  }
#endif
  u_ = new Vtb_qs;
  vs_ = VSignals::bind(u_);
#ifdef OPT_VCD_ENABLE
  if (opts.wave_enable) {
    wave_ = new VerilatedVcdC;
    u_->trace(wave_, 99);
    wave_->open(opts.wave_name.c_str());
#ifdef OPT_TRACE_ENABLE
    std::cout << "[TB] Dumping to VCD: " << opts.wave_name << "\n";
#endif
  }
#endif
}

TB::~TB() {
  delete u_;
#ifdef OPT_VCD_ENABLE
  if (wave_) {
    wave_->close();
    delete wave_;
  }
#endif
}

void TB::push_back(const DataPacket& pkt) {
  pkts_.push_back(pkt);
}

// Run simulation.
void TB::run() {
  cycle_ = 0;
  time_ = 0;

  // Run reset
  reset();

  while (!pkts_.empty()) {
    // Obtain stimulus packet
    const DataPacket data_packet{pkts_.front()};
    pkts_.pop_front();
#ifdef OPT_TRACE_ENABLE
#endif

    // Drive packet


    // Compuare output
    DataPacket actual;
    const DataPacket expected = test::compute_expected(actual);
    EXPECT_EQ(actual, expected);
  }

  /*
  
  // Drive interfaces to idle.
  Command cmd;
  vs_.set(cmd);
  
  // Response accept
  vs_.set_rsp_accept(true);

  std::map<vluint32_t, vluint8_t> uid_to_op;
  bool stopped = false;
  while (!stopped) {
    const bool cmd_full_r = vs_.get_cmd_full_r();
    if (!cmd_full_r && !cmds_.empty()) {
      // Apply input command.
      cmd = cmds_.front();
#ifdef OPT_VERBOSE
      std::cout << "[TB] Apply: " << cmd.to_string() << "\n";
#endif
      for (const Response& rsp : model_.apply(cmd)) {
#ifdef OPT_VERBOSE
        std::cout << "[TB] Predict: " << rsp.to_string(cmd.opcode) << "\n";
#endif
        rsps_.push_back(rsp);
      }

      uid_to_op.insert(std::make_pair(cmd.uid, cmd.opcode));
#ifdef OPT_TRACE_ENABLE
      if (opts_.trace_enable) {
        std::cout << "[TB] " << vs_.cycle()
                  << " ;Issue command: " << cmd.to_string() << "\n";
      }
#endif
      cmds_.pop_front();
    } else {
      // Idle
      cmd.valid = false;
    }
    vs_.set(cmd);

    Response actual;
    vs_.get(actual);
    if (actual.valid) {
      // Must be expected a response.
      ASSERT_FALSE(rsps_.empty());

      const Response expected{rsps_.front()};
      rsps_.pop_front();

      vluint8_t opcode = 0;
      if (auto it = uid_to_op.find(actual.uid); it != uid_to_op.end()) {
        // Got opcode, now able to render.
        opcode = it->second;
        uid_to_op.erase(it);
      } else if (actual.uid != 0xFFFFFFFF) {
#ifdef OPT_TRACE_ENABLE
        // Disregards controller materialized responses.
        std::cout << "[TB] " << vs_.cycle()
                  << " ; Unknown UID received: " << utility::hex(actual.uid) << "\n";
#endif
      }
#ifdef OPT_TRACE_ENABLE
      if (opts_.trace_enable) {
        std::cout << "[TB] " << vs_.cycle()
                  << " ; Response received: " << expected.to_string(opcode) << "\n";
      }
#endif
      compare(opcode, actual, expected);
    }
    step();

    // Stopped when we've received all data.
    stopped = (cmds_.empty() && rsps_.empty());
  }

  // Set interfaces to idle.
  cmd.valid = false;
  vs_.set(cmd);
  */
  
  // Wind-down simulation
  step(20);
}

void TB::reset() {
  vs_.set_rst(false);
  for (vluint64_t i = 0; i < 20; i++) {
    vs_.set_rst((i > 5) && (i < 15));
    step();
  }
  vs_.set_rst(false);
}

void TB::step(std::size_t n) {
  while (n-- > 0) {
    // !CLK region
    vs_.set_clk(false);
    u_->eval();
#ifdef OPT_VCD_ENABLE
    if (wave_) {
      wave_->dump(time());
    }
#endif
    time_ += 5;

    // CLK region
    vs_.set_clk(true);
    ++cycle_;
    u_->eval();
#ifdef OPT_VCD_ENABLE
    if (wave_) {
      wave_->dump(time());
    }
#endif
    time_ += 5;
  }
}

} // namespace tb
